import { Card } from "@/components/ui/card";
import React, { useState, useEffect } from "react";
import { 
  GraduationCap, 
  Copy, 
  CheckCircle, 
  Sparkles,
  ArrowUp, 
  ThumbsUp, 
  Award,
  Lightbulb,
  Zap,
  BookOpen,
  CheckCheck
} from "lucide-react";
import { motion, AnimatePresence } from "framer-motion";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Tooltip } from "@/components/ui/tooltip";
import { cn } from "@/lib/utils";

// New interface for question data
interface QuestionData {
  type: 'math' | 'multiplechoice' | 'trueFalse' | 'text';
  question: string;
  studentAnswer: string;
  correctAnswer: string;
  explanation?: string;
  options?: string[]; // For multiple choice questions
  subjectArea?: string; // More specific categorization (e.g., "Algebra", "Grammar", "History-WWII")
  difficulty?: 'easy' | 'medium' | 'hard';
}

interface EvaluationResultProps {
  evaluation: {
    grade?: string;
    reasoning?: string;
    improvements?: string[] | any[];
    strengths?: string[] | any[];
    rawText?: string; // Raw ChatGPT response
    [key: string]: any; // Allow any additional fields from flexible AI response
  };
  isPremium?: boolean;
  assignment?: {
    subject?: string;
    title?: string;
    content?: string;
    wordCount?: number;
    submissionDate?: string;
    assignmentType?: string; // essay, report, analysis, etc.
    questionData?: QuestionData; // New field for simple questions
  };
}

// Map Danish 7-scale grades to more generous descriptions
const gradeDescriptions: Record<string, { description: string, emoji: string, color: string, bgGradient: string }> = {
  "12": { 
    description: "Fremragende præstation! Du har demonstreret en exceptionel forståelse af emnet.",
    emoji: "🏆",
    color: "text-green-600",
    bgGradient: "from-green-400 to-emerald-500"
  },
  "10": { 
    description: "Fortrinlig præstation! Du viser stor indsigt og kun få mindre mangler.",
    emoji: "🌟",
    color: "text-emerald-600",
    bgGradient: "from-emerald-400 to-teal-500"
  },
  "7": { 
    description: "God præstation! Du har en solid forståelse med plads til forbedring.",
    emoji: "👍",
    color: "text-blue-600",
    bgGradient: "from-blue-400 to-indigo-500"
  },
  "4": { 
    description: "Jævn præstation med potentiale. Med få justeringer kan du nå meget højere!",
    emoji: "⚡",
    color: "text-yellow-600",
    bgGradient: "from-yellow-400 to-amber-500"
  },
  "02": { 
    description: "Du har opnået de grundlæggende mål. Med lidt mere arbejde kan du forbedre dig markant!",
    emoji: "🔍",
    color: "text-orange-500",
    bgGradient: "from-orange-400 to-amber-500"
  },
  "00": { 
    description: "Du er tæt på at nå målet! Med fokuseret indsats kan du bestå næste gang.",
    emoji: "🚀",
    color: "text-red-500",
    bgGradient: "from-red-400 to-orange-500"
  },
  "-3": { 
    description: "Der er plads til forbedring, men du har potentiale! Lad os fokusere på næste skridt.",
    emoji: "💪",
    color: "text-red-600",
    bgGradient: "from-red-500 to-pink-600"
  },
};

// Upgrade grades to be more generous, but only for non-math questions or correct math answers
const upgradeGrade = (grade: string, assignment?: EvaluationResultProps['assignment']): string => {
  // Don't upgrade grades for math questions with incorrect answers
  if (assignment?.questionData?.type === 'math') {
    const studentAnswer = assignment.questionData.studentAnswer;
    const correctAnswer = assignment.questionData.correctAnswer;
    
    // If the answer is incorrect, don't upgrade the grade
    if (studentAnswer !== correctAnswer) {
      return grade;
    }
  }
  
  const gradeMap: Record<string, string> = {
    "-3": "00",
    "00": "02",
    "02": "4",
    "4": "7",
    "7": "10",
    // 12 stays at 12
  };
  
  return gradeMap[grade] || grade;
};

const EvaluationResult = ({ evaluation, isPremium = false, assignment }: EvaluationResultProps) => {
  const [copiedText, setCopiedText] = useState<string | null>(null);
  const [showConfetti, setShowConfetti] = useState(false);
  const [expandedSections, setExpandedSections] = useState<Record<string, boolean>>({});
  const [activeCategory, setActiveCategory] = useState<string | null>(null);
  // Store the final grade in state to prevent it from changing during scrolling
  const [finalGrade, setFinalGrade] = useState<string | undefined>(undefined);
  // Store processed evaluation to ensure consistent formatting
  const [processedEvaluation, setProcessedEvaluation] = useState<typeof evaluation>(evaluation);
  
  // Preprocess the evaluation to ensure consistent formatting
  useEffect(() => {
    // If we have raw text, extract structured data from it
    if (evaluation.rawText) {
      const extractedImprovements = extractImprovements(evaluation.rawText);
      const overallEvaluation = extractOverallEvaluation(evaluation.rawText);
      
      // Create a processed version of the evaluation with structured data
      const processed = {
        ...evaluation,
        reasoning: overallEvaluation || evaluation.reasoning,
        improvements: extractedImprovements.length > 0 
          ? extractedImprovements.map(imp => {
              // Format as a string that our component can parse
              let formatted = "";
              if (imp.original) {
                formatted += imp.original + " ";
              }
              if (imp.context) {
                formatted += `[CITAT: "${imp.context}"] `;
              }
              if (imp.improved) {
                formatted += `OMSKRIV TIL: "${imp.improved}"`;
              }
              return formatted;
            })
          : evaluation.improvements
      };
      
      setProcessedEvaluation(processed);
    } else {
      setProcessedEvaluation(evaluation);
    }
  }, [evaluation]);
  
  // Set the final grade once on component mount
  useEffect(() => {
    if (evaluation.grade && !evaluation.rawText) {
      setFinalGrade(upgradeGrade(evaluation.grade, assignment));
    } else if (evaluation.grade) {
      setFinalGrade(evaluation.grade);
    }
  }, [evaluation.grade, evaluation.rawText, assignment]);
  
  // Generate a formatted text from structured data if rawText is not available
  const getDisplayText = () => {
    // If rawText is provided, use it directly
    if (evaluation.rawText) {
      return evaluation.rawText;
    }
    
    // Otherwise, generate a formatted text from the structured data
    let formattedText = "Jeg har læst din opgave, og jeg kan give en vurdering af den ud fra en typisk dansk gymnasial standard.\n\n";
    formattedText += "Vurdering af din opgave\n\n";
    
    // Add grade if available - use finalGrade instead of evaluation.grade
    if (finalGrade) {
      formattedText += `Karakter: ${finalGrade}\n\n`;
    }
    
    // Add reasoning/explanation if available
    if (processedEvaluation.reasoning) {
      formattedText += `${processedEvaluation.reasoning}\n\n`;
    }
    
    // Add strengths section if available
    if (processedEvaluation.strengths && processedEvaluation.strengths.length > 0) {
      formattedText += "Styrker\n";
      processedEvaluation.strengths.forEach((strength: any) => {
        if (typeof strength === 'string') {
          formattedText += `✅ ${strength}\n\n`;
        } else if (typeof strength === 'object') {
          formattedText += `✅ ${JSON.stringify(strength)}\n\n`;
        }
      });
    }
    
    // Add improvements section if available
    if (processedEvaluation.improvements && processedEvaluation.improvements.length > 0) {
      formattedText += "Forbedringspunkter\n";
      processedEvaluation.improvements.forEach((improvement: any) => {
        if (typeof improvement === 'string') {
          formattedText += `❌ ${improvement}\n\n`;
        } else if (typeof improvement === 'object') {
          formattedText += `❌ ${JSON.stringify(improvement)}\n\n`;
        }
      });
    }
    
    // Add any additional sections from the evaluation
    Object.entries(processedEvaluation).forEach(([key, value]) => {
      // Skip already processed fields and empty values
      if (['grade', 'reasoning', 'strengths', 'improvements', 'rawText'].includes(key) || 
          !value || key.startsWith('_')) {
        return;
      }
      
      // Format the section title
      const sectionTitle = key.charAt(0).toUpperCase() + key.slice(1).replace(/([A-Z])/g, ' $1');
      formattedText += `${sectionTitle}\n\n`;
      
      // Format the content based on its type
      if (typeof value === 'string') {
        formattedText += `${value}\n\n`;
      } else if (Array.isArray(value)) {
        value.forEach((item: any) => {
          if (typeof item === 'string') {
            formattedText += `• ${item}\n`;
          } else if (typeof item === 'object') {
            formattedText += `• ${JSON.stringify(item)}\n`;
          }
        });
        formattedText += "\n";
      }
    });
    
    // Add a conclusion
    formattedText += "Konklusion\n\n";
    formattedText += "Tak for din opgave. Jeg håber, at min feedback er nyttig for dit videre arbejde. Hvis du har spørgsmål til vurderingen, er du velkommen til at spørge. 📚✨";
    
    return formattedText;
  };

  // Extract improvement suggestions with "better versions" from text
  const extractImprovements = (text: string) => {
    const improvements: { original: string; improved: string; prefix?: string; context?: string }[] = [];
    
    // Look for patterns like:
    // "Fagligt indhold: Manglende dybde i analysen [CITAT: "Det er samtidig et bevis på den amerikanske drøm..."] OMSKRIV TIL: "Denne passage illustrerer..."
    const regex = /([^"]+)\[CITAT: "([^"]+)"\]\s*OMSKRIV TIL:\s*"([^"]+)"\s*(?:FORBEDRING:\s*([^"]+))?/g;
    let match;
    
    while ((match = regex.exec(text)) !== null) {
      improvements.push({
        original: match[1].trim(),
        context: match[2].trim(),
        improved: match[3].trim(),
        prefix: match[4] ? match[4].trim() : undefined
      });
    }
    
    // Look for patterns like "FORBEDRING: En tydeligere konklusion..." with embedded citations
    const forbedringRegex = /FORBEDRING:\s*([^❌\[]+)(?:❌\s*([^[]+))?\s*\[CITAT:\s*"([^"]+)"\]/gi;
    while ((match = forbedringRegex.exec(text)) !== null) {
      const original = match[2] ? match[2].trim() : "Forbedringspotentiale i formuleringen";
      improvements.push({
        original: original,
        context: match[3].trim(),
        improved: match[1].trim(),
        prefix: "FORBEDRING"
      });
    }
    
    // Look for patterns like "Struktur: Manglende dybde i analysen [CITAT: 'Den indre monolog i slutningen...'] OMSKRIV TIL: 'Den indre monolog afslører..."
    const singleQuoteRegex = /([^']+)\[CITAT: '([^']+)'\]\s*OMSKRIV TIL:\s*'([^']+)'\s*(?:FORBEDRING:\s*([^']+))?/g;
    while ((match = singleQuoteRegex.exec(text)) !== null) {
      improvements.push({
        original: match[1].trim(),
        context: match[2].trim(),
        improved: match[3].trim(),
        prefix: match[4] ? match[4].trim() : undefined
      });
    }
    
    // If no matches found, try the simpler pattern
    if (improvements.length === 0) {
      const simpleRegex = /"([^"]+)"\s*–\s*(?:(Det burde være|Bedre formulering kunne være:|OMSKRIV TIL:))\s*"([^"]+)"/g;
      while ((match = simpleRegex.exec(text)) !== null) {
        improvements.push({
          original: match[1],
          improved: match[3],
          prefix: match[2]
        });
      }
    }
    
    // Also look for any quoted text that might be citations
    const quotedTextRegex = /"([^"]{15,})"/g;
    const foundQuotes = new Set<string>();
    
    // Add already found quotes to the set to avoid duplicates
    improvements.forEach(imp => {
      if (imp.context) foundQuotes.add(imp.context);
    });
    
    // Find additional quotes that could be used as citations
    while ((match = quotedTextRegex.exec(text)) !== null) {
      const quote = match[1].trim();
      // Only add if it's not already included and is reasonably long
      if (!foundQuotes.has(quote) && quote.length > 20 && quote.length < 200) {
        foundQuotes.add(quote);
        // For these quotes, we don't have specific improvements yet
        improvements.push({
          original: "Forbedringspotentiale i formuleringen",
          context: quote,
          improved: "", // Will be generated later
          prefix: undefined
        });
      }
    }
    
    // Clean up any malformed improvements
    return improvements.map(imp => {
      // Check if the context contains both original and improved text
      if (imp.context && imp.context.includes("FORBEDRING:")) {
        const parts = imp.context.split("FORBEDRING:");
        if (parts.length > 1) {
          return {
            ...imp,
            context: parts[0].trim(),
            improved: parts[1].trim()
          };
        }
      }
      
      // Check if the context contains both original and improved text with other markers
      if (imp.context && (imp.context.includes("kunne omformuleres til:") || imp.context.includes("OMSKRIV TIL:"))) {
        let contextPart = imp.context;
        let improvedPart = "";
        
        if (imp.context.includes("kunne omformuleres til:")) {
          const parts = imp.context.split("kunne omformuleres til:");
          if (parts.length > 1) {
            contextPart = parts[0].trim();
            improvedPart = parts[1].trim();
          }
        } else if (imp.context.includes("OMSKRIV TIL:")) {
          const parts = imp.context.split("OMSKRIV TIL:");
          if (parts.length > 1) {
            contextPart = parts[0].trim();
            improvedPart = parts[1].trim();
          }
        }
        
        // If we successfully split it
        if (improvedPart) {
          return {
            ...imp,
            context: contextPart,
            improved: improvedPart.replace(/^"|"$/g, '') // Remove quotes if present
          };
        }
      }
      
      // Check if the original contains category markers that should be separated
      if (imp.original && imp.original.includes("❌")) {
        const parts = imp.original.split("❌");
        if (parts.length > 1) {
          return {
            ...imp,
            original: parts[1].trim()
          };
        }
      }
      
      return imp;
    });
  };

  // Extract overall evaluation from text
  const extractOverallEvaluation = (text: string) => {
    // Look for patterns like "Jeg har læst din opgave, og jeg kan give en vurdering..."
    const regex = /Jeg har læst din opgave[^\.]+\.\s*([^]*?)(?=Styrker|Forbedringspunkter|Konklusion|$)/i;
    const match = regex.exec(text);
    
    if (match && match[1]) {
      return match[1].trim();
    }
    
    return null;
  };

  // Clean up improvement text to remove the overall evaluation
  const cleanImprovementText = (text: string) => {
    // Remove the standard intro text that appears in every evaluation
    const introPattern = /^Jeg har læst din opgave, og jeg kan give en vurdering af den ud fra en typisk dansk gymnasial standard\.\s*Vurdering af din opgave\s*Karakter:\s*\d+\s*/i;
    let cleaned = text.replace(introPattern, '');
    
    // Remove any text that looks like an overall evaluation
    const evalPattern = /Besvarelsen demonstrerer en[^\.]+\./g;
    cleaned = cleaned.replace(evalPattern, '');
    
    // Remove any strengths section markers
    const strengthsPattern = /Styrker\s*✅/g;
    cleaned = cleaned.replace(strengthsPattern, '');
    
    // Remove all the strengths and positive points that come before the actual improvement
    const strengthsRemovalPattern = /.*?(?:Fagligt indhold|Struktur|Sprog|Kritisk tænkning|Praktisk anvendelse):[^❌]+✅\s*/g;
    cleaned = cleaned.replace(strengthsRemovalPattern, '');
    
    // Remove "Forbedringspunkter" text
    cleaned = cleaned.replace(/Forbedringspunkter\s*/, '');
    
    // Focus on just the specific improvement point after the ❌ symbol
    if (cleaned.includes('❌')) {
      const parts = cleaned.split('❌');
      if (parts.length > 1) {
        // Take the part after the ❌ symbol
        cleaned = parts[1].trim();
      }
    }
    
    // If there are multiple improvement points, take only the first one
    const specificPattern = /Fagligt indhold:|Sprog:|Struktur:|Kritisk tænkning:|Praktisk anvendelse:/i;
    const match = specificPattern.exec(cleaned);
    
    if (match) {
      // Get the text from the specific improvement marker
      const startIndex = cleaned.indexOf(match[0]);
      if (startIndex >= 0) {
        cleaned = cleaned.substring(startIndex);
        
        // If there's another improvement point after this one, cut it off
        const nextImprovement = cleaned.indexOf('❌', 1);
        if (nextImprovement > 0) {
          cleaned = cleaned.substring(0, nextImprovement).trim();
        }
      }
    }
    
    return cleaned.trim();
  };

  // Handle copying text to clipboard - only copy the improved text
  const copyToClipboard = (text: string) => {
    navigator.clipboard.writeText(text);
    setCopiedText(text);
    setTimeout(() => setCopiedText(null), 2000);
  };

  // Show confetti animation when component mounts
  useEffect(() => {
    setShowConfetti(true);
    const timer = setTimeout(() => setShowConfetti(false), 3000);
    return () => clearTimeout(timer);
  }, []);

  // Toggle section expansion
  const toggleSection = (section: string) => {
    setExpandedSections(prev => ({
      ...prev,
      [section]: !prev[section]
    }));
  };

  // Get the text to display
  const displayText = getDisplayText();
  
  // Extract improvements for interactive features
  const improvements = extractImprovements(displayText);

  // Generate more detailed improvement suggestions with diverse feedback types
  const generateDetailedImprovements = (text: string) => {
    // Base improvements from the text
    const extractedImprovements = extractImprovements(text);
    
    // Define the interface for improvement objects
    interface DetailedImprovement {
      category: string;
      original: string;
      context?: string;
      suggestions: { title: string; improved: string; explanation: string; note?: string }[];
    }
    
    // Helper function to clean up citation text
    const cleanCitationText = (text: string): string => {
      // Remove any embedded improvement suggestions
      let cleaned = text;
      
      // Remove "FORBEDRING:" and everything after it
      if (cleaned.includes("FORBEDRING:")) {
        cleaned = cleaned.split("FORBEDRING:")[0].trim();
      }
      
      // Remove "OMSKRIV TIL:" and everything after it
      if (cleaned.includes("OMSKRIV TIL:")) {
        cleaned = cleaned.split("OMSKRIV TIL:")[0].trim();
      }
      
      // Remove category markers
      cleaned = cleaned.replace(/❌\s*Sprog:/gi, "").trim();
      cleaned = cleaned.replace(/❌\s*Fagligt indhold:/gi, "").trim();
      cleaned = cleaned.replace(/❌\s*Struktur:/gi, "").trim();
      cleaned = cleaned.replace(/❌\s*Kritisk tænkning:/gi, "").trim();
      cleaned = cleaned.replace(/❌\s*Praktisk anvendelse:/gi, "").trim();
      
      // Remove quotes if they're at the beginning and end
      cleaned = cleaned.replace(/^"|"$/g, "").trim();
      
      return cleaned;
    };
    
    // Helper function to separate the improvement text from explanatory notes
    const separateImprovedTextAndNote = (text: string): { improvedText: string; note?: string } => {
      // Common patterns for explanatory notes
      const notePatterns = [
        /\.\s*(Dette giver teksten et mere professionelt udtryk\.?)$/,
        /\.\s*(Dette vil give din opgave mere dybde og præcision\.?)$/,
        /\.\s*(Herved bliver din argumentation mere overbevisende\.?)$/,
        /\.\s*(Dette vil løfte kvaliteten af din opgave betydeligt\.?)$/,
        /\.\s*(Dette leder til en mere overbevisende konklusion på dit argument\.?)$/
      ];
      
      for (const pattern of notePatterns) {
        const match = text.match(pattern);
        if (match) {
          // Return the text without the explanatory note, and the note separately
          return {
            improvedText: text.replace(pattern, '.'),
            note: match[1]
          };
        }
      }
      
      // If no explanatory note is found, return the original text
      return { improvedText: text };
    };
    
    // Generate default improvement suggestions based on the improvement type and citation context
    const generateDefaultSuggestions = (improvementText: string, context?: string): { title: string; improved: string; explanation: string; note?: string }[] => {
      const suggestions = [];
      
      // Clean up the context if provided
      const cleanContext = context ? cleanCitationText(context) : context;
      
      // If we have a citation context but no specific improvement yet, generate one based on the content
      if (cleanContext && (!improvementText || improvementText === "Forbedringspotentiale i formuleringen")) {
        // Analyze the citation to determine what kind of improvement would be most relevant
        const lowerContext = cleanContext.toLowerCase();
        
        if (lowerContext.includes('derfor') || lowerContext.includes('således') || lowerContext.includes('dermed') || 
            lowerContext.includes('følgelig') || lowerContext.includes('heraf')) {
          // Looks like a conclusion or reasoning statement
          suggestions.push({
            title: 'Styrk argumentationen',
            improved: `"${cleanContext}" kunne styrkes til: "Dette underbygger argumentet om, at ${cleanContext.replace(/derfor|således|dermed|følgelig|heraf/gi, '').trim()}"`,
            explanation: 'Stærkere argumentation gør dine pointer mere overbevisende.'
          });
          
          suggestions.push({
            title: 'Tilføj faglig præcision',
            improved: `"${cleanContext}" kunne omformuleres til: "Analysen viser, at ${cleanContext.replace(/derfor|således|dermed|følgelig|heraf/gi, '').trim()}"`,
            explanation: 'Faglig præcision giver din tekst mere akademisk tyngde.'
          });
        } 
        else if (lowerContext.includes('mange') || lowerContext.includes('flere') || lowerContext.includes('nogle') || 
                 lowerContext.includes('få') || lowerContext.includes('visse')) {
          // Vague quantifiers that could be more specific
          suggestions.push({
            title: 'Konkretisér mængdeangivelser',
            improved: `"${cleanContext}" kunne præciseres til: "${cleanContext.replace(/mange|flere|nogle|få|visse/gi, 'cirka 70%')}"`,
            explanation: 'Specifikke tal og procenter gør din analyse mere præcis og troværdig.'
          });
          
          suggestions.push({
            title: 'Underbyg med data',
            improved: `"${cleanContext}" kunne styrkes med data: "${cleanContext.replace(/mange|flere|nogle|få|visse/gi, 'en betydelig andel (68% ifølge undersøgelsen)')}"`,
            explanation: 'Konkrete data giver dine argumenter mere vægt og troværdighed.'
          });
        }
        else if (lowerContext.includes('god') || lowerContext.includes('dårlig') || lowerContext.includes('bedre') || 
                 lowerContext.includes('værre') || lowerContext.includes('fin')) {
          // Subjective evaluations that could be more objective
          suggestions.push({
            title: 'Objektivér vurderingen',
            improved: `"${cleanContext}" kunne objektiveres til: "${cleanContext.replace(/god|dårlig|bedre|værre|fin/gi, 'effektiv baseret på følgende kriterier')}"`,
            explanation: 'Objektive vurderinger baseret på klare kriterier styrker din akademiske argumentation.'
          });
          
          suggestions.push({
            title: 'Nuancér vurderingen',
            improved: `"${cleanContext}" kunne nuanceres til: "${cleanContext.replace(/god|dårlig|bedre|værre|fin/gi, 'hensigtsmæssig i denne kontekst, men med visse begrænsninger')}"`,
            explanation: 'Nuancerede vurderinger viser din evne til at se kompleksiteten i emnet.'
          });
        }
        else {
          // Generic improvements for any citation
          suggestions.push({
            title: 'Styrk faglig formulering',
            improved: `"${cleanContext}" kunne omformuleres til: "Ud fra et fagligt perspektiv kan man observere, at ${cleanContext.toLowerCase().replace(/^[^a-zæøå]+ /i, '')}"`,
            explanation: 'Faglige formuleringer demonstrerer din akademiske forståelse af emnet.'
          });
          
          suggestions.push({
            title: 'Tilføj analytisk dybde',
            improved: `"${cleanContext}" kunne uddybes til: "${cleanContext} Dette er særligt relevant, fordi det illustrerer sammenhængen mellem teori og praksis i den givne kontekst."`,
            explanation: 'Analytisk dybde viser din evne til at se og forklare sammenhænge.'
          });
        }
        
        // Add a third suggestion that's more specific to the content
        if (lowerContext.includes('marked') || lowerContext.includes('virksomhed') || lowerContext.includes('strategi')) {
          // Business/economics content
          suggestions.push({
            title: 'Anvend fagbegreber',
            improved: `"${cleanContext}" kunne styrkes med fagbegreber: "${cleanContext.replace(/marked/gi, 'markedssegment').replace(/virksomhed/gi, 'organisation').replace(/strategi/gi, 'strategisk positionering')}"`,
            explanation: 'Korrekt anvendelse af fagbegreber viser din beherskelse af fagets terminologi.'
          });
        }
        else if (lowerContext.includes('tekst') || lowerContext.includes('forfatter') || lowerContext.includes('læser')) {
          // Literature/language content
          suggestions.push({
            title: 'Inddrag sproglige virkemidler',
            improved: `"${cleanContext}" kunne uddybes med: "${cleanContext} Forfatteren anvender her metaforer og billedsprog til at skabe en emotionel forbindelse til læseren."`,
            explanation: 'Analyse af sproglige virkemidler viser din forståelse for tekstens opbygning og effekt.'
          });
        }
        else if (lowerContext.includes('samfund') || lowerContext.includes('politik') || lowerContext.includes('social')) {
          // Social studies content
          suggestions.push({
            title: 'Tilføj samfundsfaglig vinkel',
            improved: `"${cleanContext}" kunne uddybes med: "${cleanContext} Set fra et sociologisk perspektiv afspejler dette de strukturelle magtforhold i samfundet."`,
            explanation: 'Samfundsfaglige perspektiver viser din evne til at analysere sociale strukturer og dynamikker.'
          });
        }
        else {
          // Generic third suggestion
          suggestions.push({
            title: 'Underbyg med eksempel',
            improved: `"${cleanContext}" kunne underbygges med: "${cleanContext} Et konkret eksempel på dette er [indsæt specifikt eksempel], som illustrerer pointen tydeligt."`,
            explanation: 'Konkrete eksempler gør dine argumenter mere forståelige og overbevisende.'
          });
        }
        
        return suggestions;
      }
      
      // Check what type of improvement this is (existing logic)
      if (improvementText.includes('konkretisering af strategier') || improvementText.includes('Praktisk anvendelse')) {
        // For strategy concretization
        // ... existing code ...
      } 
      else if (improvementText.includes('fagbegreber') || improvementText.includes('Fagligt indhold')) {
        // For academic terminology
        // ... existing code ...
      }
      else if (improvementText.includes('analyse') || improvementText.includes('Analyse')) {
        // For analysis depth
        // ... existing code ...
      }
      else {
        // Generic improvements for other categories
        // ... existing code ...
      }
      
      return suggestions;
    };
    
    // Generate additional citations from the assignment content if available
    const generateAdditionalCitations = (assignment?: EvaluationResultProps['assignment']): { original: string; context: string; improved: string; prefix?: string }[] => {
      const additionalCitations = [];
      
      if (assignment?.content) {
        // Split content into sentences or paragraphs
        const sentences = assignment.content
          .replace(/([.!?])\s+/g, "$1|")
          .split("|")
          .filter(s => s.length > 30 && s.length < 200); // Only reasonably sized sentences
        
        // Select up to 3 random sentences to use as citations
        const selectedSentences = [];
        if (sentences.length > 0) {
          // Try to get sentences from different parts of the text
          const third = Math.floor(sentences.length / 3);
          if (third > 0) {
            // Get one from each third if possible
            selectedSentences.push(
              sentences[Math.floor(Math.random() * third)],
              sentences[Math.floor(Math.random() * third) + third],
              sentences[Math.floor(Math.random() * third) + 2 * third]
            );
          } else {
            // Just get random ones if text is short
            for (let i = 0; i < Math.min(3, sentences.length); i++) {
              selectedSentences.push(sentences[Math.floor(Math.random() * sentences.length)]);
            }
          }
          
          // Create improvement objects for each selected sentence
          selectedSentences.forEach(sentence => {
            additionalCitations.push({
              original: "Forbedringspotentiale i formuleringen",
              context: sentence.trim(),
              improved: "", // Will be generated by generateDefaultSuggestions
              prefix: undefined
            });
          });
        }
      }
      
      return additionalCitations;
    };
    
    // If we have extracted improvements, enhance them with more diverse details
    if (extractedImprovements.length > 0) {
      // Add additional citations from the assignment content if we don't have many
      if (extractedImprovements.length < 3 && assignment?.content) {
        const additionalCitations = generateAdditionalCitations(assignment);
        extractedImprovements.push(...additionalCitations);
      }
      
      return extractedImprovements.map((imp, index) => {
        // Determine the category based on the original text
        const original = imp.original || "";
        const category = original.includes('sprog') ? 'Sprog' :
                         original.includes('struktur') ? 'Struktur' :
                         original.includes('analyse') ? 'Analyse' :
                         original.includes('argument') ? 'Argumentation' :
                         original.includes('kilde') ? 'Kildehenvisning' :
                         original.includes('Praktisk anvendelse') ? 'Praktisk anvendelse' : 'Generelt';
        
        // Clean up the original text to remove overall evaluation
        const cleanedOriginal = cleanCitationText(original);
        
        // Clean up the context if it exists
        const cleanedContext = imp.context ? cleanCitationText(imp.context) : undefined;
        
        // Generate diverse suggestions based on the original improvement
        let suggestions = [];
        
        // If there's an improved text provided, use it as the first suggestion
        if (imp.improved && imp.improved.trim().length > 0) {
          // Clean up the improved text
          const cleanedImproved = imp.improved.replace(/^"|"$/g, '').trim();
          
          suggestions.push({
            title: 'Direkte forbedring',
            improved: cleanedImproved,
            explanation: 'Dette er en direkte forbedring af den originale formulering, som gør dit argument klarere.'
          });
          
          // Generate alternative improvements based on the content
          if (imp.original.includes('analyse')) {
            // ... existing code for analysis improvements ...
          } 
          else if (imp.original.includes('faglig')) {
            // ... existing code for academic content improvements ...
          }
          // ... other existing conditions ...
        } else {
          // If no improved text is provided, generate default suggestions based on the improvement type
          suggestions = generateDefaultSuggestions(cleanedOriginal, cleanedContext);
        }
        
        return {
          category,
          original: cleanedOriginal,
          context: cleanedContext,
          suggestions
        } as DetailedImprovement;
      });
    }
    
    // If no extracted improvements, use the existing generic ones
    if (evaluation.improvements && evaluation.improvements.length > 0) {
      // For each improvement point, generate diverse detailed suggestions
      const detailedImprovements: DetailedImprovement[] = [];
      
      evaluation.improvements.forEach((improvement: any, index: number) => {
        if (typeof improvement === 'string') {
          // Clean up the improvement text
          const cleanedImprovement = cleanImprovementText(improvement);
          
          // Generate a category from the improvement
          const category = cleanedImprovement.includes('sprog') ? 'Sprog' :
                           cleanedImprovement.includes('struktur') ? 'Struktur' :
                           cleanedImprovement.includes('analyse') ? 'Analyse' :
                           cleanedImprovement.includes('argument') ? 'Argumentation' :
                           cleanedImprovement.includes('kilde') ? 'Kildehenvisning' :
                           cleanedImprovement.includes('Praktisk anvendelse') ? 'Praktisk anvendelse' : 'Generelt';
          
          // Generate default suggestions based on the improvement type
          const suggestions = generateDefaultSuggestions(cleanedImprovement);
          
          detailedImprovements.push({
            category,
            original: cleanedImprovement,
            suggestions
          });
        }
      });
      
      // Add additional citations from the assignment content
      if (assignment?.content) {
        const additionalCitations = generateAdditionalCitations(assignment);
        
        additionalCitations.forEach(citation => {
          const suggestions = generateDefaultSuggestions("Forbedringspotentiale i formuleringen", citation.context);
          
          detailedImprovements.push({
            category: 'Formulering',
            original: "Forbedringspotentiale i formuleringen",
            context: citation.context,
            suggestions
          });
        });
      }
      
      return detailedImprovements;
    }
    
    return [];
  };

  // For raw text display, we'll use our enhanced formatter instead of the basic one
  if (evaluation.rawText) {
    // Extract structured data from the raw text
    const extractedImprovements = extractImprovements(evaluation.rawText);
    
    // If we have extracted improvements, use the structured display
    if (extractedImprovements.length > 0) {
      // Use the structured display with our extracted data
      return (
        <div className="space-y-6">
          {/* Confetti animation */}
          <AnimatePresence>
            {showConfetti && (
              <motion.div 
                className="fixed inset-0 pointer-events-none z-50 overflow-hidden"
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                exit={{ opacity: 0 }}
              >
                {Array.from({ length: 100 }).map((_, i) => (
                  <motion.div
                    key={i}
                    className="absolute w-3 h-3 rounded-full"
                    style={{
                      backgroundColor: `hsl(${Math.random() * 360}, 100%, 50%)`,
                      top: `${Math.random() * 100}%`,
                      left: `${Math.random() * 100}%`,
                    }}
                    initial={{ 
                      y: -20, 
                      opacity: 0 
                    }}
                    animate={{ 
                      y: `${Math.random() * 100 + 100}vh`, 
                      opacity: [0, 1, 1, 0],
                      scale: [0, 1, 1, 0.5],
                      rotate: `${Math.random() * 360}deg`
                    }}
                    transition={{ 
                      duration: 2 + Math.random() * 2,
                      ease: "easeOut",
                      delay: Math.random() * 0.5
                    }}
                  />
                ))}
              </motion.div>
            )}
          </AnimatePresence>

          <Card className="p-6 relative overflow-hidden bg-white shadow-md">
            {/* Header with title */}
            <div className="flex items-center mb-4 pb-4 border-b border-gray-100">
              <div className="bg-blue-100 p-2 rounded-full mr-3">
                <GraduationCap className="h-5 w-5 text-blue-600" />
              </div>
              <h2 className="text-lg font-semibold text-gray-800">AI Evaluering</h2>
            </div>
            
            {/* Main content */}
            <div className="space-y-6">
              {/* Overall evaluation section */}
              {extractOverallEvaluation(evaluation.rawText) && (
                <motion.div 
                  className="p-4 rounded-lg border border-blue-100 bg-blue-50"
                  initial={{ y: 20, opacity: 0 }}
                  animate={{ y: 0, opacity: 1 }}
                  transition={{ delay: 0.9 }}
                >
                  <div className="flex items-center mb-3">
                    <BookOpen className="h-5 w-5 text-blue-600 mr-2" />
                    <h3 className="text-lg font-medium text-blue-800">Overordnet vurdering</h3>
                  </div>
                  
                  <div className="bg-white p-4 rounded-md shadow-sm">
                    <p className="text-gray-700 whitespace-pre-line">
                      {extractOverallEvaluation(evaluation.rawText)}
                    </p>
                  </div>
                </motion.div>
              )}

              {/* Enhanced Improvements section with cleaner, more structured feedback */}
              <motion.div 
                className="p-4 rounded-lg border border-amber-100 bg-amber-50"
                initial={{ y: 20, opacity: 0 }}
                animate={{ y: 0, opacity: 1 }}
                transition={{ delay: 1.3 }}
              >
                <div className="flex items-center justify-between mb-3">
                  <div className="flex items-center">
                    <Lightbulb className="h-5 w-5 text-amber-600 mr-2" />
                    <h3 className="text-lg font-medium text-amber-800">Forbedringsforslag</h3>
                  </div>
                  
                  <div className="text-sm text-amber-700">
                    <span className="font-medium">{extractedImprovements.length}</span> forbedringspunkter
                  </div>
                </div>
                
                {/* Generate detailed improvements */}
                {(() => {
                  const detailedImprovements = generateDetailedImprovements(evaluation.rawText);
                  const categories = [...new Set(detailedImprovements.map(imp => imp.category))];
                  
                  return (
                    <div className="space-y-6">
                      {/* Category navigation */}
                      {categories.length > 1 && (
                        <div className="flex flex-wrap gap-2 pb-3 border-b border-amber-200">
                          {categories.map(category => (
                            <Button
                              key={category}
                              variant={activeCategory === category ? "default" : "outline"}
                              size="sm"
                              onClick={() => setActiveCategory(activeCategory === category ? null : category)}
                              className={cn(
                                "transition-all",
                                activeCategory === category 
                                  ? "bg-amber-500 text-white" 
                                  : "text-amber-700 hover:bg-amber-100"
                              )}
                            >
                              {category}
                            </Button>
                          ))}
                          {activeCategory && (
                            <Button
                              variant="ghost"
                              size="sm"
                              onClick={() => setActiveCategory(null)}
                              className="text-gray-500"
                            >
                              Vis alle
                            </Button>
                          )}
                        </div>
                      )}
                      
                      {/* Detailed improvements - cleaner, more structured layout */}
                      <div className="space-y-6 max-h-[600px] overflow-y-auto pr-2 custom-scrollbar">
                        {detailedImprovements
                          .filter(imp => !activeCategory || imp.category === activeCategory)
                          .map((improvement, index) => (
                            <motion.div 
                              key={index}
                              className="bg-white p-5 rounded-lg shadow-sm border border-amber-100"
                              initial={{ x: 20, opacity: 0 }}
                              animate={{ x: 0, opacity: 1 }}
                              transition={{ delay: 1.3 + (index * 0.1) }}
                            >
                              <div className="flex items-center justify-between mb-3 pb-2 border-b border-gray-100">
                                <div className="flex items-center">
                                  <Badge className="bg-amber-100 text-amber-800 mr-2">{improvement.category}</Badge>
                                  <h4 className="font-medium text-gray-800">Forbedringspunkt {index + 1}</h4>
                                </div>
                                <Button
                                  variant="ghost"
                                  size="sm"
                                  onClick={() => toggleSection(`improvement-${index}`)}
                                  className="text-gray-500"
                                >
                                  {expandedSections[`improvement-${index}`] ? 'Minimer' : 'Udvid'}
                                </Button>
                              </div>
                              
                              {/* Citation section - simplified to focus on the citation */}
                              {improvement.context && (
                                <div className="mb-4 p-3 bg-gray-50 rounded-md border border-gray-200">
                                  <div className="flex items-start">
                                    <div className="flex-1">
                                      <p className="text-gray-700 font-medium mb-1">Citat:</p>
                                      <p className="text-gray-600 italic">"{improvement.context}"</p>
                                    </div>
                                  </div>
                                </div>
                              )}
                              
                              {/* Original text - more structured layout */}
                              <div className="mb-4 p-3 bg-red-50 rounded-md">
                                <div className="flex items-start">
                                  <span className="text-red-500 mr-2 mt-1 flex-shrink-0">❌</span>
                                  <div className="flex-1">
                                    <p className="text-gray-700 font-medium mb-1">Forbedringspunkt:</p>
                                    <p className="text-gray-600">
                                      {improvement.original && improvement.original !== "Forbedringspotentiale i formuleringen" 
                                        ? improvement.original 
                                        : "Forbedringspotentiale i formuleringen"}
                                    </p>
                                  </div>
                                </div>
                              </div>
                              
                              <AnimatePresence>
                                {(expandedSections[`improvement-${index}`] !== false) && (
                                  <motion.div
                                    initial={{ height: 0, opacity: 0 }}
                                    animate={{ height: "auto", opacity: 1 }}
                                    exit={{ height: 0, opacity: 0 }}
                                    className="overflow-hidden"
                                  >
                                    <div className="space-y-4">
                                      {improvement.suggestions.map((suggestion, sIndex) => (
                                        <div key={sIndex} className="p-3 bg-green-50 rounded-md">
                                          <div className="flex items-center mb-2">
                                            <span className="text-green-500 mr-2 flex-shrink-0">✅</span>
                                            <p className="text-gray-700 font-medium">{suggestion.title}</p>
                                          </div>
                                          
                                          <div className="flex flex-col mb-2 pl-7">
                                            <div className="flex items-start justify-between">
                                              <div className="flex-1">
                                                <p className="text-gray-800 font-medium mb-1">OMSKRIV TIL:</p>
                                                <p className="text-green-700 bg-green-100 p-2 rounded-md">{suggestion.improved}</p>
                                                {suggestion.note && (
                                                  <p className="text-gray-600 italic mt-1 text-sm">{suggestion.note}</p>
                                                )}
                                              </div>
                                              <Button
                                                variant="outline"
                                                size="sm"
                                                className="ml-2 text-gray-600 hover:text-green-600 hover:border-green-300 flex-shrink-0 mt-6"
                                                onClick={() => copyToClipboard(suggestion.improved)}
                                              >
                                                {copiedText === suggestion.improved ? (
                                                  <div className="flex items-center">
                                                    <CheckCheck className="h-4 w-4 text-green-500 mr-1" />
                                                    <span className="text-green-500">Kopieret</span>
                                                  </div>
                                                ) : (
                                                  <div className="flex items-center">
                                                    <Copy className="h-4 w-4 mr-1" />
                                                    <span>Kopiér</span>
                                                  </div>
                                                )}
                                              </Button>
                                            </div>
                                            
                                            <div className="bg-blue-50 p-2 rounded-md mt-2">
                                              <p className="text-sm text-blue-700">{suggestion.explanation}</p>
                                            </div>
                                          </div>
                                        </div>
                                      ))}
                                    </div>
                                  </motion.div>
                                )}
                              </AnimatePresence>
                              
                              {expandedSections[`improvement-${index}`] === false && (
                                <Button 
                                  variant="outline" 
                                  size="sm"
                                  className="mt-2 w-full text-amber-600 border-amber-200 hover:bg-amber-50"
                                  onClick={() => toggleSection(`improvement-${index}`)}
                                >
                                  Vis {improvement.suggestions.length} forbedringsforslag
                                </Button>
                              )}
                            </motion.div>
                          ))}
                        </div>
                      </div>
                    );
                  })()}
                </motion.div>
              )}
              
              {/* Conclusion */}
              <motion.div 
                className="mt-6 p-4 rounded-lg bg-gradient-to-r from-purple-50 to-pink-50 border border-purple-100"
                initial={{ y: 20, opacity: 0 }}
                animate={{ y: 0, opacity: 1 }}
                transition={{ delay: 1.5 }}
              >
                <div className="flex items-center mb-2">
                  <Sparkles className="h-5 w-5 text-purple-600 mr-2" />
                  <h3 className="text-lg font-medium text-purple-800">Næste skridt</h3>
                </div>
                <p className="text-gray-700">
                  Tak for din opgave! Du har gjort et godt stykke arbejde. 
                  Fokuser på de foreslåede forbedringer, og din næste opgave vil blive endnu bedre. 
                  Husk at du altid kan spørge, hvis du har brug for yderligere hjælp. 
                  <span className="ml-1">💪✨</span>
                </p>
              </motion.div>
            </div>
          </Card>
        </div>
      );
    }
    
    // If we couldn't extract improvements, fall back to the basic formatter
    // Process the text to preserve formatting but make it HTML-safe
    const processText = (text: string) => {
      return text
        // Preserve emojis and special characters
        .replace(/✅/g, '<span class="text-green-500">✅</span>')
        .replace(/❌/g, '<span class="text-red-500">❌</span>')
        .replace(/📌/g, '<span class="text-blue-500">📌</span>')
        .replace(/📊/g, '<span class="text-purple-500">📊</span>')
        .replace(/💪/g, '<span>💪</span>')
        .replace(/😊/g, '<span>😊</span>')
        // Format citation patterns to make them more readable
        .replace(/\[CITAT: "([^"]+)"\]/g, '<div class="p-2 bg-gray-100 rounded my-2 italic">"$1"</div>')
        .replace(/OMSKRIV TIL: "([^"]+)"/g, '<div class="p-2 bg-green-100 rounded my-2">$1</div>')
        .replace(/FORBEDRING: ([^[]+)/g, '<div class="text-blue-600">$1</div>')
        // Convert newlines to <br> tags
        .split('\n').join('<br />');
    };

    return (
      <div className="space-y-6">
        <Card className="p-6 relative overflow-hidden bg-white shadow-md">
          <div className="flex items-center mb-4 pb-4 border-b border-gray-100">
            <div className="bg-blue-100 p-2 rounded-full mr-3">
              <GraduationCap className="h-5 w-5 text-blue-600" />
            </div>
            <h2 className="text-lg font-semibold text-gray-800">AI Evaluering</h2>
          </div>
                
          <div className="prose prose-blue max-w-none">
            <div 
              className="text-gray-700 whitespace-pre-wrap font-sans text-base leading-relaxed"
              dangerouslySetInnerHTML={{ 
                __html: processText(displayText || "Ingen evaluering tilgængelig endnu.") 
              }}
            />
          </div>
        </Card>
      </div>
    );
  }

  // For structured data, we'll create an enhanced interactive display
  return (
    <div className="space-y-6">
      {/* Confetti animation */}
      <AnimatePresence>
        {showConfetti && (
          <motion.div 
            className="fixed inset-0 pointer-events-none z-50 overflow-hidden"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
          >
            {Array.from({ length: 100 }).map((_, i) => (
              <motion.div
                key={i}
                className="absolute w-3 h-3 rounded-full"
                style={{
                  backgroundColor: `hsl(${Math.random() * 360}, 100%, 50%)`,
                  top: `${Math.random() * 100}%`,
                  left: `${Math.random() * 100}%`,
                }}
                initial={{ 
                  y: -20, 
                  opacity: 0 
                }}
                animate={{ 
                  y: `${Math.random() * 100 + 100}vh`, 
                  opacity: [0, 1, 1, 0],
                  scale: [0, 1, 1, 0.5],
                  rotate: `${Math.random() * 360}deg`
                }}
                transition={{ 
                  duration: 2 + Math.random() * 2,
                  ease: "easeOut",
                  delay: Math.random() * 0.5
                }}
              />
            ))}
          </motion.div>
        )}
      </AnimatePresence>

      <Card className="p-6 relative overflow-hidden bg-white shadow-md">
        {/* Header with title */}
        <div className="flex items-center mb-4 pb-4 border-b border-gray-100">
          <div className="bg-blue-100 p-2 rounded-full mr-3">
            <GraduationCap className="h-5 w-5 text-blue-600" />
          </div>
          <h2 className="text-lg font-semibold text-gray-800">AI Evaluering</h2>
        </div>
        
        {/* Add special section for math questions with incorrect answers */}
        {assignment?.questionData?.type === 'math' && 
         assignment.questionData.studentAnswer !== assignment.questionData.correctAnswer && (
          <motion.div 
            className="mb-6 p-4 rounded-lg bg-red-50 border border-red-100"
            initial={{ y: 20, opacity: 0 }}
            animate={{ y: 0, opacity: 1 }}
            transition={{ delay: 0.5 }}
          >
            <div className="flex items-start">
              <span className="text-red-500 mr-2 mt-1 flex-shrink-0">❌</span>
              <div>
                <p className="font-medium text-red-700 mb-1">Dit svar er ikke korrekt</p>
                <div className="flex flex-col space-y-2">
                  <div className="flex">
                    <span className="font-medium w-32">Spørgsmål:</span>
                    <span>{assignment.questionData.question}</span>
                  </div>
                  <div className="flex">
                    <span className="font-medium w-32">Dit svar:</span>
                    <span className="text-red-600">{assignment.questionData.studentAnswer}</span>
                  </div>
                  <div className="flex">
                    <span className="font-medium w-32">Korrekt svar:</span>
                    <span className="text-green-600">{assignment.questionData.correctAnswer}</span>
                  </div>
                  {assignment.questionData.explanation && (
                    <div className="flex">
                      <span className="font-medium w-32">Forklaring:</span>
                      <span>{assignment.questionData.explanation}</span>
                    </div>
                  )}
                </div>
              </div>
            </div>
          </motion.div>
        )}
        
        {/* Centered grade display - use finalGrade instead of evaluation.grade */}
        {finalGrade && (
          <motion.div 
            className="flex flex-col items-center justify-center mb-6"
            initial={{ y: -20, opacity: 0 }}
            animate={{ y: 0, opacity: 1 }}
            transition={{ delay: 0.3 }}
          >
            <motion.div 
              className="mb-4"
              initial={{ scale: 0.5, opacity: 0, rotate: -10 }}
              animate={{ 
                scale: [0.5, 1.2, 1], 
                opacity: 1, 
                rotate: [0, 5, 0],
                y: [0, -10, 0]
              }}
              transition={{ 
                duration: 0.8, 
                ease: "easeOut",
                times: [0, 0.6, 1]
              }}
            >
              <div className={cn(
                "relative flex items-center justify-center",
                "w-28 h-28 rounded-full shadow-lg",
                "bg-gradient-to-br",
                gradeDescriptions[finalGrade]?.bgGradient || "from-blue-400 to-indigo-500"
              )}>
                <motion.div
                  className="absolute inset-0 rounded-full opacity-50"
                  animate={{ 
                    scale: [1, 1.1, 1],
                    opacity: [0.5, 0.8, 0.5]
                  }}
                  transition={{
                    duration: 2,
                    repeat: Infinity,
                    ease: "easeInOut"
                  }}
                  style={{
                    background: `radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%)`
                  }}
                />
                <div className="flex flex-col items-center justify-center text-white">
                  <span className="text-5xl font-bold">{finalGrade}</span>
                  <span className="text-2xl mt-1">{gradeDescriptions[finalGrade]?.emoji || "🎓"}</span>
                </div>
              </div>
            </motion.div>
            
            <motion.div 
              className="w-full max-w-lg p-4 rounded-lg bg-gradient-to-r from-blue-50 to-indigo-50"
              initial={{ y: 20, opacity: 0 }}
              animate={{ y: 0, opacity: 1 }}
              transition={{ delay: 0.7 }}
            >
              <div className="flex items-start">
                <Award className="h-5 w-5 text-yellow-500 mr-2 mt-1 flex-shrink-0" />
                <p className={cn(
                  "font-medium text-center",
                  gradeDescriptions[finalGrade]?.color || "text-gray-700"
                )}>
                  {gradeDescriptions[finalGrade]?.description || 
                   "Godt arbejde med din opgave!"}
                </p>
              </div>
            </motion.div>
          </motion.div>
        )}
        
        {/* Main content */}
        <div className="space-y-6">
          {/* Overall evaluation section - moved from reasoning to be more prominent */}
          {(evaluation.reasoning || extractOverallEvaluation(displayText)) && (
            <motion.div 
              className="p-4 rounded-lg border border-blue-100 bg-blue-50"
              initial={{ y: 20, opacity: 0 }}
              animate={{ y: 0, opacity: 1 }}
              transition={{ delay: 0.9 }}
            >
              <div className="flex items-center mb-3">
                <BookOpen className="h-5 w-5 text-blue-600 mr-2" />
                <h3 className="text-lg font-medium text-blue-800">Overordnet vurdering</h3>
              </div>
              
              <div className="bg-white p-4 rounded-md shadow-sm">
                <p className="text-gray-700 whitespace-pre-line">
                  {evaluation.reasoning || extractOverallEvaluation(displayText)}
                </p>
              </div>
            </motion.div>
          )}

          {/* Strengths section */}
          {evaluation.strengths && evaluation.strengths.length > 0 && (
            <motion.div
              className="p-4 rounded-lg border border-green-100 bg-green-50"
              initial={{ y: 20, opacity: 0 }}
              animate={{ y: 0, opacity: 1 }}
              transition={{ delay: 1.1 }}
            >
              <div className="flex items-center mb-3">
                <ThumbsUp className="h-5 w-5 text-green-600 mr-2" />
                <h3 className="text-lg font-medium text-green-800">Styrker</h3>
              </div>
              
              <ul className="space-y-3">
                {evaluation.strengths.map((strength: any, index: number) => (
                  <motion.li 
                    key={index}
                    className="flex items-start bg-white p-3 rounded-md shadow-sm"
                    initial={{ x: -20, opacity: 0 }}
                    animate={{ x: 0, opacity: 1 }}
                    transition={{ delay: 1.1 + (index * 0.1) }}
                  >
                    <CheckCircle className="h-5 w-5 text-green-500 mr-2 mt-0.5 flex-shrink-0" />
                    <span className="text-gray-700">
                      {typeof strength === 'string' ? strength : JSON.stringify(strength)}
                    </span>
                  </motion.li>
                ))}
              </ul>
            </motion.div>
          )}
          
          {/* Enhanced Improvements section with cleaner, more structured feedback */}
          {evaluation.improvements && evaluation.improvements.length > 0 && (
            <motion.div 
              className="p-4 rounded-lg border border-amber-100 bg-amber-50"
              initial={{ y: 20, opacity: 0 }}
              animate={{ y: 0, opacity: 1 }}
              transition={{ delay: 1.3 }}
            >
              <div className="flex items-center justify-between mb-3">
                <div className="flex items-center">
                  <Lightbulb className="h-5 w-5 text-amber-600 mr-2" />
                  <h3 className="text-lg font-medium text-amber-800">Forbedringsforslag</h3>
                </div>
                
                <div className="text-sm text-amber-700">
                  <span className="font-medium">{generateDetailedImprovements(displayText).length}</span> forbedringspunkter
                </div>
              </div>
              
              {/* Generate detailed improvements */}
              {(() => {
                const detailedImprovements = generateDetailedImprovements(displayText);
                const categories = [...new Set(detailedImprovements.map(imp => imp.category))];
                
                return (
                  <div className="space-y-6">
                    {/* Category navigation */}
                    {categories.length > 1 && (
                      <div className="flex flex-wrap gap-2 pb-3 border-b border-amber-200">
                        {categories.map(category => (
                          <Button
                            key={category}
                            variant={activeCategory === category ? "default" : "outline"}
                            size="sm"
                            onClick={() => setActiveCategory(activeCategory === category ? null : category)}
                            className={cn(
                              "transition-all",
                              activeCategory === category 
                                ? "bg-amber-500 text-white" 
                                : "text-amber-700 hover:bg-amber-100"
                            )}
                          >
                            {category}
                          </Button>
                        ))}
                        {activeCategory && (
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => setActiveCategory(null)}
                            className="text-gray-500"
                          >
                            Vis alle
                          </Button>
                        )}
                      </div>
                    )}
                    
                    {/* Detailed improvements - cleaner, more structured layout */}
                    <div className="space-y-6 max-h-[600px] overflow-y-auto pr-2 custom-scrollbar">
                      {detailedImprovements
                        .filter(imp => !activeCategory || imp.category === activeCategory)
                        .map((improvement, index) => (
                          <motion.div 
                            key={index}
                            className="bg-white p-5 rounded-lg shadow-sm border border-amber-100"
                            initial={{ x: 20, opacity: 0 }}
                            animate={{ x: 0, opacity: 1 }}
                            transition={{ delay: 1.3 + (index * 0.1) }}
                          >
                            <div className="flex items-center justify-between mb-3 pb-2 border-b border-gray-100">
                              <div className="flex items-center">
                                <Badge className="bg-amber-100 text-amber-800 mr-2">{improvement.category}</Badge>
                                <h4 className="font-medium text-gray-800">Forbedringspunkt {index + 1}</h4>
                              </div>
                              <Button
                                variant="ghost"
                                size="sm"
                                onClick={() => toggleSection(`improvement-${index}`)}
                                className="text-gray-500"
                              >
                                {expandedSections[`improvement-${index}`] ? 'Minimer' : 'Udvid'}
                              </Button>
                            </div>
                            
                            {/* Citation section - simplified to focus on the citation */}
                            {improvement.context && (
                              <div className="mb-4 p-3 bg-gray-50 rounded-md border border-gray-200">
                                <div className="flex items-start">
                                  <div className="flex-1">
                                    <p className="text-gray-700 font-medium mb-1">Citat:</p>
                                    <p className="text-gray-600 italic">"{improvement.context}"</p>
                                  </div>
                                </div>
                              </div>
                            )}
                            
                            {/* Original text - more structured layout */}
                            <div className="mb-4 p-3 bg-red-50 rounded-md">
                              <div className="flex items-start">
                                <span className="text-red-500 mr-2 mt-1 flex-shrink-0">❌</span>
                                <div className="flex-1">
                                  <p className="text-gray-700 font-medium mb-1">Forbedringspunkt:</p>
                                  <p className="text-gray-600">
                                    {improvement.original && improvement.original !== "Forbedringspotentiale i formuleringen" 
                                      ? improvement.original 
                                      : "Forbedringspotentiale i formuleringen"}
                                  </p>
                                </div>
                              </div>
                            </div>
                            
                            <AnimatePresence>
                              {(expandedSections[`improvement-${index}`] !== false) && (
                                <motion.div
                                  initial={{ height: 0, opacity: 0 }}
                                  animate={{ height: "auto", opacity: 1 }}
                                  exit={{ height: 0, opacity: 0 }}
                                  className="overflow-hidden"
                                >
                                  <div className="space-y-4">
                                    {improvement.suggestions.map((suggestion, sIndex) => (
                                      <div key={sIndex} className="p-3 bg-green-50 rounded-md">
                                        <div className="flex items-center mb-2">
                                          <span className="text-green-500 mr-2 flex-shrink-0">✅</span>
                                          <p className="text-gray-700 font-medium">{suggestion.title}</p>
                                        </div>
                                        
                                        <div className="flex flex-col mb-2 pl-7">
                                          <div className="flex items-start justify-between">
                                            <div className="flex-1">
                                              <p className="text-gray-800 font-medium mb-1">OMSKRIV TIL:</p>
                                              <p className="text-green-700 bg-green-100 p-2 rounded-md">{suggestion.improved}</p>
                                              {suggestion.note && (
                                                <p className="text-gray-600 italic mt-1 text-sm">{suggestion.note}</p>
                                              )}
                                            </div>
                                            <Button
                                              variant="outline"
                                              size="sm"
                                              className="ml-2 text-gray-600 hover:text-green-600 hover:border-green-300 flex-shrink-0 mt-6"
                                              onClick={() => copyToClipboard(suggestion.improved)}
                                            >
                                              {copiedText === suggestion.improved ? (
                                                <div className="flex items-center">
                                                  <CheckCheck className="h-4 w-4 text-green-500 mr-1" />
                                                  <span className="text-green-500">Kopieret</span>
                                                </div>
                                              ) : (
                                                <div className="flex items-center">
                                                  <Copy className="h-4 w-4 mr-1" />
                                                  <span>Kopiér</span>
                                                </div>
                                              )}
                                            </Button>
                                          </div>
                                          
                                          <div className="bg-blue-50 p-2 rounded-md mt-2">
                                            <p className="text-sm text-blue-700">{suggestion.explanation}</p>
                                          </div>
                                        </div>
                                      </div>
                                    ))}
                                  </div>
                                </motion.div>
                              )}
                            </AnimatePresence>
                            
                            {expandedSections[`improvement-${index}`] === false && (
                              <Button 
                                variant="outline" 
                                size="sm"
                                className="mt-2 w-full text-amber-600 border-amber-200 hover:bg-amber-50"
                                onClick={() => toggleSection(`improvement-${index}`)}
                              >
                                Vis {improvement.suggestions.length} forbedringsforslag
                              </Button>
                            )}
                          </motion.div>
                        ))}
                    </div>
                  </div>
                );
              })()}
            </motion.div>
          )}
          
          {/* Conclusion */}
          <motion.div 
            className="mt-6 p-4 rounded-lg bg-gradient-to-r from-purple-50 to-pink-50 border border-purple-100"
            initial={{ y: 20, opacity: 0 }}
            animate={{ y: 0, opacity: 1 }}
            transition={{ delay: 1.5 }}
          >
            <div className="flex items-center mb-2">
              <Sparkles className="h-5 w-5 text-purple-600 mr-2" />
              <h3 className="text-lg font-medium text-purple-800">Næste skridt</h3>
            </div>
            <p className="text-gray-700">
              Tak for din opgave! Du har gjort et godt stykke arbejde. 
              Fokuser på de foreslåede forbedringer, og din næste opgave vil blive endnu bedre. 
              Husk at du altid kan spørge, hvis du har brug for yderligere hjælp. 
              <span className="ml-1">💪✨</span>
            </p>
          </motion.div>
        </div>
      </Card>
    </div>
  );
};

export default EvaluationResult;
